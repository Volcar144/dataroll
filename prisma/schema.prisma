generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DIRECT_URL")
}

// BetterAuth Models
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // BetterAuth relations
  accounts Account[]
  sessions Session[]

  // dataroll specific relations
  teamMembers       TeamMember[]
  createdTeams      Team[]             @relation("TeamCreator")
  databaseConnections DatabaseConnection[]
  migrations        Migration[]
  auditLogs         AuditLog[]
  notificationPreferences NotificationPreferences?
  autoApprovalRules AutoApprovalRule[]
  apiKeys           ApiKey[]
  twoFactorAuth     TwoFactorAuth?
  passkeyCredentials PasskeyCredential[]
  teamInvitations   TeamInvitation[]  @relation("UserInvitations")
  requestedApprovals MigrationApproval[] @relation("ApprovalRequester")
  givenApprovals    MigrationApproval[] @relation("ApprovalApprover")
  scheduledExecutions ScheduledExecution[]
  webhooks          Webhook[]             @relation("UserWebhooks")
  pendingQueries    PendingQuery[]
  proxyConnections  ProxyConnection[]
  approvedQueries   PendingQuery[]      @relation("QueryApprover")
  workflowDefinitions WorkflowDefinition[]
  workflowApprovals  WorkflowApproval[] @relation("WorkflowApprover")
  approvalResponses  ApprovalResponse[]
  createdWorkflows   Workflow[]         @relation("WorkflowCreator")

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// dataroll-specific models
model Team {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String

  createdBy User @relation("TeamCreator", fields: [createdById], references: [id])
  members   TeamMember[]
  databaseConnections DatabaseConnection[]
  migrations Migration[]
  auditLogs AuditLog[]
  invitations TeamInvitation[]
  permissions TeamPermission[]
  webhooks Webhook[]
  scheduledExecutions ScheduledExecution[]
  autoApprovalRules AutoApprovalRule[]
  apiKeys ApiKey[]
  workflows Workflow[]

  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      TeamRole
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

enum TeamRole {
  OWNER
  ADMIN
  DEVELOPER
  VIEWER
  MEMBER
}

enum Permission {
  // Team management
  TEAM_MANAGE
  TEAM_INVITE
  TEAM_REMOVE_MEMBER
  
  // Database connections
  CONNECTION_CREATE
  CONNECTION_UPDATE
  CONNECTION_DELETE
  CONNECTION_TEST
  
  // Migrations
  MIGRATION_CREATE
  MIGRATION_EXECUTE
  MIGRATION_ROLLBACK
  MIGRATION_APPROVE
  
  // Audit
  AUDIT_VIEW
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum Environment {
  DEVELOPMENT
  STAGING
  PRODUCTION
}

model TeamInvitation {
  id          String   @id @default(cuid())
  teamId      String
  email       String
  role        TeamRole
  invitedById String
  token       String   @unique
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedBy User @relation("UserInvitations", fields: [invitedById], references: [id])

  @@map("team_invitations")
}

model TeamPermission {
  id         String   @id @default(cuid())
  teamId     String
  role       TeamRole
  permission Permission
  createdAt  DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, role, permission])
  @@map("team_permissions")
}

model MigrationApproval {
  id            String   @id @default(cuid())
  migrationId   String
  requestedById String
  approvedById  String?
  status        ApprovalStatus @default(PENDING)
  comments      String?
  approvedAt    DateTime?
  expiresAt     DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  migration   Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)
  requestedBy User      @relation("ApprovalRequester", fields: [requestedById], references: [id])
  approvedBy  User?     @relation("ApprovalApprover", fields: [approvedById], references: [id])

  @@map("migration_approvals")
}

model ScheduledExecution {
  id            String   @id @default(cuid())
  migrationId   String
  teamId        String
  databaseConnectionId String
  scheduledById String
  scheduledFor  DateTime
  executedAt    DateTime?
  status        ExecutionStatus @default(PENDING)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)
  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  databaseConnection DatabaseConnection @relation(fields: [databaseConnectionId], references: [id], onDelete: Cascade)
  scheduledBy User @relation(fields: [scheduledById], references: [id])

  @@unique([migrationId, scheduledFor])
  @@map("scheduled_executions")
}

model Webhook {
  id          String   @id @default(cuid())
  teamId      String
  name        String
  url         String
  secret      String
  events      String[] // JSON array of events to trigger on
  isActive    Boolean  @default(true)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdBy User @relation("UserWebhooks", fields: [createdById], references: [id])
  deliveries WebhookDelivery[]

  @@map("webhooks")
}

model WebhookDelivery {
  id         String   @id @default(cuid())
  webhookId  String
  event      String
  payload    String   @db.Text
  signature  String?
  response   String?  @db.Text
  statusCode Int?
  status     String?  @default("PENDING")
  error      String?
  success    Boolean  @default(false)
  deliveredAt DateTime?
  createdAt  DateTime @default(now())

  webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@map("webhook_deliveries")
}

model DatabaseConnection {
  id           String   @id @default(cuid())
  name         String
  type         DatabaseType
  host         String
  port         Int?
  database    String
  username    String
  password    String   // encrypted
  ssl         Boolean  @default(false)
  url         String?  // direct connection string
  environment Environment @default(DEVELOPMENT)
  requiresApproval Boolean @default(false)
  isActive    Boolean  @default(true)
  healthStatus ConnectionHealthStatus @default(UNKNOWN)
  lastHealthCheck DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  teamId      String
  createdById String

  team      Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdBy User          @relation(fields: [createdById], references: [id])
  migrations Migration[]
  scheduledExecutions ScheduledExecution[]
  errors    DatabaseError[]
  pendingQueries PendingQuery[]
  proxyConnections ProxyConnection[]
  autoApprovalRules AutoApprovalRule[]

  @@map("database_connections")
}

enum DatabaseType {
  POSTGRESQL
  MYSQL
  SQLITE
}

enum ConnectionHealthStatus {
  HEALTHY
  UNHEALTHY
  UNKNOWN
}

model DatabaseError {
  id         String   @id @default(cuid())
  connectionId String
  operation  String   // e.g., "connection_test", "migration_execute", "query"
  errorType  String   // e.g., "connection_failed", "query_error", "timeout"
  message    String   @db.Text
  details    String?  @db.Text // additional error details, stack trace, etc.
  occurredAt DateTime @default(now())

  connection DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@map("database_errors")
}

model Migration {
  id          String            @id @default(cuid())
  name        String
  version     String
  type        MigrationType
  filePath    String
  content     String            @db.Text
  status      MigrationStatus   @default(PENDING)
  checksum    String?
  notes       String?           @db.Text
  executedAt  DateTime?
  rolledBackAt DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  teamId      String
  databaseConnectionId String
  createdById String

  team               Team                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  databaseConnection DatabaseConnection  @relation(fields: [databaseConnectionId], references: [id], onDelete: Cascade)
  createdBy          User               @relation(fields: [createdById], references: [id])
  executions         MigrationExecution[]
  rollbacks          MigrationRollback[]
  approvals          MigrationApproval[]
  scheduledExecutions ScheduledExecution[]

  @@unique([teamId, version, databaseConnectionId])
  @@map("migrations")
}

enum MigrationType {
  PRISMA
  DRIZZLE
  RAW_SQL
}

enum MigrationStatus {
  PENDING
  EXECUTING
  EXECUTED
  FAILED
  ROLLED_BACK
}

model MigrationExecution {
  id          String   @id @default(cuid())
  migrationId String
  status      ExecutionStatus
  duration    Int?     // in milliseconds
  error       String?  @db.Text
  executedAt  DateTime @default(now())
  executedBy  String

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)

  @@map("migration_executions")
}

enum ExecutionStatus {
  PENDING
  SUCCESS
  FAILURE
  ROLLBACK
}

model MigrationRollback {
  id              String   @id @default(cuid())
  migrationId     String
  reason          String?
  rolledBackAt    DateTime @default(now())
  rolledBackBy    String
  backupLocation  String?

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)

  @@map("migration_rollbacks")
}

model AuditLog {
  id        String     @id @default(cuid())
  action    AuditAction
  resource  String
  resourceId String?
  details   String?    @db.Text
  ipAddress String?
  userAgent String?
  createdAt DateTime   @default(now())
  teamId    String
  userId    String

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

enum AuditAction {
  USER_LOGIN
  USER_LOGOUT
  TEAM_CREATED
  TEAM_UPDATED
  TEAM_DELETED
  MEMBER_ADDED
  MEMBER_REMOVED
  MEMBER_ROLE_CHANGED
  CONNECTION_CREATED
  CONNECTION_UPDATED
  CONNECTION_DELETED
  MIGRATION_CREATED
  MIGRATION_EXECUTED
  MIGRATION_ROLLED_BACK
  MIGRATION_FAILED
}

model TwoFactorAuth {
  id        String   @id @default(cuid())
  userId    String   @unique
  enabled   Boolean  @default(false)
  secret    String?
  backupCodes String[] @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

model PasskeyCredential {
  id              String   @id @default(cuid())
  userId          String
  name            String?
  publicKey       String   @db.Text
  counter         BigInt   @default(0)
  deviceType      String?
  backedUp        Boolean  @default(false)
  transports      String[] @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("passkey_credentials")
}

model NotificationPreferences {
  id              String   @id @default(cuid())
  userId          String   @unique
  emailOnSuccess  Boolean  @default(true)
  emailOnFailure  Boolean  @default(true)
  emailOnRollback Boolean  @default(true)
  slackWebhook    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model AutoApprovalRule {
  id           String   @id @default(cuid())
  userId       String
  connectionId String?
  teamId       String?
  queryPattern String?  // Regex pattern to match queries
  maxRows      Int?     // Maximum rows allowed for auto-approval
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user       User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  connection DatabaseConnection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  team       Team?               @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@map("auto_approval_rules")
}

model ApiKey {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String?
  userId      String
  teamId      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@map("api_keys")
}

model PendingQuery {
  id           String   @id @default(cuid())
  query        String   @db.Text
  params       Json?
  connectionId String
  userId       String
  status       QueryStatus @default(PENDING)
  approvedById String?
  approvedAt   DateTime?
  executedAt   DateTime?
  result       Json?
  error        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  connection   DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id])
  approvedBy   User?              @relation("QueryApprover", fields: [approvedById], references: [id])

  @@map("pending_queries")
}

model ProxyConnection {
  id           String   @id @default(cuid())
  connectionId String
  userId       String
  proxyUrl     String   @unique
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  connection   DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id])

  @@map("proxy_connections")
}

enum QueryStatus {
  PENDING
  APPROVED
  REJECTED
  EXECUTED
  FAILED
}

// Workflow System Models
model Workflow {
  id String @id @default(cuid())
  teamId String
  name String
  description String? @db.Text

  // Current workflow definition
  definitionId String @unique

  // Versioning
  version Int @default(1)
  isPublished Boolean @default(false)
  publishedAt DateTime?

  // Metadata
  tags String[] @default([])
  trigger String // "manual", "scheduled", "webhook", "event"

  // Tracking
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  definitions WorkflowDefinition[]
  executions WorkflowExecution[]
  triggers WorkflowTrigger[]
  variables WorkflowVariable[]
  approvals WorkflowApproval[]
  creator User @relation("WorkflowCreator", fields: [createdBy], references: [id])

  @@map("workflows")
}

model WorkflowDefinition {
  id String @id @default(cuid())
  workflowId String

  // YAML/JSON storage
  content String @db.Text // Full workflow definition
  format String @default("json") // "json" or "yaml"

  // Metadata
  nodes String @db.Text // Serialized nodes array
  edges String @db.Text // Serialized edges array

  // Version control
  version Int
  changelog String? @db.Text

  createdAt DateTime @default(now())
  createdBy String

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  creator User @relation(fields: [createdBy], references: [id])

  @@map("workflow_definitions")
}

model WorkflowExecution {
  id String @id @default(cuid())
  workflowId String

  // Execution state
  status String // "pending", "running", "success", "failed", "cancelled"

  // Triggers
  triggeredBy String // userId or "schedule" or "webhook"
  triggeredAt DateTime @default(now())
  startedAt DateTime?
  completedAt DateTime?

  // Execution data
  context String @db.Text // Input variables/context
  output String? @db.Text // Final output
  error String? @db.Text // Error details

  // Tracking
  nodeExecutions NodeExecution[]
  approvals WorkflowApproval[]

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@map("workflow_executions")
}

model NodeExecution {
  id String @id @default(cuid())
  executionId String

  // Node identification
  nodeId String
  nodeType String // "trigger", "action", "condition", "approval", "notification", etc
  nodeName String

  // Execution state
  status String // "pending", "running", "success", "failed", "skipped"

  // Data flow
  input String @db.Text // Input to this node
  output String? @db.Text // Output from this node
  error String? @db.Text // Error if failed

  // Timing
  startedAt DateTime?
  completedAt DateTime?
  duration Int? // milliseconds

  // Retry info
  retryCount Int @default(0)
  retryable Boolean @default(false)

  execution WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@map("node_executions")
}

model WorkflowTrigger {
  id String @id @default(cuid())
  workflowId String

  // Trigger configuration
  type String // "manual", "scheduled", "webhook", "on_event"
  config String @db.Text // Trigger-specific config (cron, event filter, webhook key, etc)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@map("workflow_triggers")
}

model WorkflowVariable {
  id String @id @default(cuid())
  workflowId String

  name String
  type String // "string", "number", "boolean", "object", "secret"
  defaultValue String? @db.Text
  description String? @db.Text
  isSecret Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@unique([workflowId, name])
  @@map("workflow_variables")
}

model WorkflowApproval {
  id String @id @default(cuid())
  workflowId String
  executionId String
  nodeId String
  nodeName String

  status ApprovalStatus @default(PENDING)
  approvalType String // "any", "majority", "unanimous"
  approvers String[] // User IDs
  requiredApprovals Int
  timeoutMinutes Int?
  message String? @db.Text
  context String? @db.Text // JSON context data

  approvedBy String? // User ID who approved
  approvedAt DateTime?
  rejectionReason String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  execution WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  approvals ApprovalResponse[]
  approver User? @relation("WorkflowApprover", fields: [approvedBy], references: [id])

  @@map("workflow_approvals")
}

model ApprovalResponse {
  id String @id @default(cuid())
  approvalId String

  userId String
  decision String // "approved", "rejected"
  comment String? @db.Text

  createdAt DateTime @default(now())

  approval WorkflowApproval @relation(fields: [approvalId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])

  @@unique([approvalId, userId])
  @@map("approval_responses")
}