generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DIRECT_URL")
}

// BetterAuth Models
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // BetterAuth relations
  accounts Account[]
  sessions Session[]

  // dataroll specific relations
  teamMembers       TeamMember[]
  createdTeams      Team[]             @relation("TeamCreator")
  databaseConnections DatabaseConnection[]
  migrations        Migration[]
  auditLogs         AuditLog[]
  notificationPreferences NotificationPreferences?
  twoFactorAuth     TwoFactorAuth?
  passkeyCredentials PasskeyCredential[]
  teamInvitations   TeamInvitation[]  @relation("UserInvitations")
  requestedApprovals MigrationApproval[] @relation("ApprovalRequester")
  givenApprovals    MigrationApproval[] @relation("ApprovalApprover")
  scheduledExecutions ScheduledExecution[]
  webhooks          Webhook[]             @relation("UserWebhooks")
  pendingQueries    PendingQuery[]
  proxyConnections  ProxyConnection[]
  approvedQueries   PendingQuery[]      @relation("QueryApprover")

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// dataroll-specific models
model Team {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String

  createdBy User @relation("TeamCreator", fields: [createdById], references: [id])
  members   TeamMember[]
  databaseConnections DatabaseConnection[]
  migrations Migration[]
  auditLogs AuditLog[]
  invitations TeamInvitation[]
  permissions TeamPermission[]
  webhooks Webhook[]
  scheduledExecutions ScheduledExecution[]

  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      TeamRole
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

enum TeamRole {
  OWNER
  ADMIN
  DEVELOPER
  VIEWER
  MEMBER
}

enum Permission {
  // Team management
  TEAM_MANAGE
  TEAM_INVITE
  TEAM_REMOVE_MEMBER
  
  // Database connections
  CONNECTION_CREATE
  CONNECTION_UPDATE
  CONNECTION_DELETE
  CONNECTION_TEST
  
  // Migrations
  MIGRATION_CREATE
  MIGRATION_EXECUTE
  MIGRATION_ROLLBACK
  MIGRATION_APPROVE
  
  // Audit
  AUDIT_VIEW
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum Environment {
  DEVELOPMENT
  STAGING
  PRODUCTION
}

model TeamInvitation {
  id          String   @id @default(cuid())
  teamId      String
  email       String
  role        TeamRole
  invitedById String
  token       String   @unique
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedBy User @relation("UserInvitations", fields: [invitedById], references: [id])

  @@map("team_invitations")
}

model TeamPermission {
  id         String   @id @default(cuid())
  teamId     String
  role       TeamRole
  permission Permission
  createdAt  DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, role, permission])
  @@map("team_permissions")
}

model MigrationApproval {
  id            String   @id @default(cuid())
  migrationId   String
  requestedById String
  approvedById  String?
  status        ApprovalStatus @default(PENDING)
  comments      String?
  approvedAt    DateTime?
  expiresAt     DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  migration   Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)
  requestedBy User      @relation("ApprovalRequester", fields: [requestedById], references: [id])
  approvedBy  User?     @relation("ApprovalApprover", fields: [approvedById], references: [id])

  @@map("migration_approvals")
}

model ScheduledExecution {
  id            String   @id @default(cuid())
  migrationId   String
  teamId        String
  databaseConnectionId String
  scheduledById String
  scheduledFor  DateTime
  executedAt    DateTime?
  status        ExecutionStatus @default(PENDING)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)
  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  databaseConnection DatabaseConnection @relation(fields: [databaseConnectionId], references: [id], onDelete: Cascade)
  scheduledBy User @relation(fields: [scheduledById], references: [id])

  @@unique([migrationId, scheduledFor])
  @@map("scheduled_executions")
}

model Webhook {
  id          String   @id @default(cuid())
  teamId      String
  name        String
  url         String
  secret      String
  events      String[] // JSON array of events to trigger on
  isActive    Boolean  @default(true)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  team      Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdBy User @relation("UserWebhooks", fields: [createdById], references: [id])
  deliveries WebhookDelivery[]

  @@map("webhooks")
}

model WebhookDelivery {
  id         String   @id @default(cuid())
  webhookId  String
  event      String
  payload    String   @db.Text
  signature  String?
  response   String?  @db.Text
  statusCode Int?
  status     String?  @default("PENDING")
  error      String?
  success    Boolean  @default(false)
  deliveredAt DateTime?
  createdAt  DateTime @default(now())

  webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@map("webhook_deliveries")
}

model DatabaseConnection {
  id           String   @id @default(cuid())
  name         String
  type         DatabaseType
  host         String
  port         Int?
  database    String
  username    String
  password    String   // encrypted
  ssl         Boolean  @default(false)
  url         String?  // direct connection string
  environment Environment @default(DEVELOPMENT)
  requiresApproval Boolean @default(false)
  isActive    Boolean  @default(true)
  healthStatus ConnectionHealthStatus @default(UNKNOWN)
  lastHealthCheck DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  teamId      String
  createdById String

  team      Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdBy User          @relation(fields: [createdById], references: [id])
  migrations Migration[]
  scheduledExecutions ScheduledExecution[]
  errors    DatabaseError[]
  pendingQueries PendingQuery[]
  proxyConnections ProxyConnection[]

  @@map("database_connections")
}

enum DatabaseType {
  POSTGRESQL
  MYSQL
  SQLITE
}

enum ConnectionHealthStatus {
  HEALTHY
  UNHEALTHY
  UNKNOWN
}

model DatabaseError {
  id         String   @id @default(cuid())
  connectionId String
  operation  String   // e.g., "connection_test", "migration_execute", "query"
  errorType  String   // e.g., "connection_failed", "query_error", "timeout"
  message    String   @db.Text
  details    String?  @db.Text // additional error details, stack trace, etc.
  occurredAt DateTime @default(now())

  connection DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@map("database_errors")
}

model Migration {
  id          String            @id @default(cuid())
  name        String
  version     String
  type        MigrationType
  filePath    String
  content     String            @db.Text
  status      MigrationStatus   @default(PENDING)
  checksum    String?
  notes       String?           @db.Text
  executedAt  DateTime?
  rolledBackAt DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  teamId      String
  databaseConnectionId String
  createdById String

  team               Team                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  databaseConnection DatabaseConnection  @relation(fields: [databaseConnectionId], references: [id], onDelete: Cascade)
  createdBy          User               @relation(fields: [createdById], references: [id])
  executions         MigrationExecution[]
  rollbacks          MigrationRollback[]
  approvals          MigrationApproval[]
  scheduledExecutions ScheduledExecution[]

  @@unique([teamId, version, databaseConnectionId])
  @@map("migrations")
}

enum MigrationType {
  PRISMA
  DRIZZLE
  RAW_SQL
}

enum MigrationStatus {
  PENDING
  EXECUTING
  EXECUTED
  FAILED
  ROLLED_BACK
}

model MigrationExecution {
  id          String   @id @default(cuid())
  migrationId String
  status      ExecutionStatus
  duration    Int?     // in milliseconds
  error       String?  @db.Text
  executedAt  DateTime @default(now())
  executedBy  String

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)

  @@map("migration_executions")
}

enum ExecutionStatus {
  PENDING
  SUCCESS
  FAILURE
  ROLLBACK
}

model MigrationRollback {
  id              String   @id @default(cuid())
  migrationId     String
  reason          String?
  rolledBackAt    DateTime @default(now())
  rolledBackBy    String
  backupLocation  String?

  migration Migration @relation(fields: [migrationId], references: [id], onDelete: Cascade)

  @@map("migration_rollbacks")
}

model AuditLog {
  id        String     @id @default(cuid())
  action    AuditAction
  resource  String
  resourceId String?
  details   String?    @db.Text
  ipAddress String?
  userAgent String?
  createdAt DateTime   @default(now())
  teamId    String
  userId    String

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

enum AuditAction {
  USER_LOGIN
  USER_LOGOUT
  TEAM_CREATED
  TEAM_UPDATED
  TEAM_DELETED
  MEMBER_ADDED
  MEMBER_REMOVED
  MEMBER_ROLE_CHANGED
  CONNECTION_CREATED
  CONNECTION_UPDATED
  CONNECTION_DELETED
  MIGRATION_CREATED
  MIGRATION_EXECUTED
  MIGRATION_ROLLED_BACK
  MIGRATION_FAILED
}

model TwoFactorAuth {
  id        String   @id @default(cuid())
  userId    String   @unique
  enabled   Boolean  @default(false)
  secret    String?
  backupCodes String[] @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

model PasskeyCredential {
  id              String   @id @default(cuid())
  userId          String
  name            String?
  publicKey       String   @db.Text
  counter         BigInt   @default(0)
  deviceType      String?
  backedUp        Boolean  @default(false)
  transports      String[] @db.Text
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("passkey_credentials")
}

model NotificationPreferences {
  id              String   @id @default(cuid())
  userId          String   @unique
  emailOnSuccess  Boolean  @default(true)
  emailOnFailure  Boolean  @default(true)
  emailOnRollback Boolean  @default(true)
  slackWebhook    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model PendingQuery {
  id           String   @id @default(cuid())
  query        String   @db.Text
  params       Json?
  connectionId String
  userId       String
  status       QueryStatus @default(PENDING)
  approvedById String?
  approvedAt   DateTime?
  executedAt   DateTime?
  result       Json?
  error        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  connection   DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id])
  approvedBy   User?              @relation("QueryApprover", fields: [approvedById], references: [id])

  @@map("pending_queries")
}

model ProxyConnection {
  id           String   @id @default(cuid())
  connectionId String
  userId       String
  proxyUrl     String   @unique
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  connection   DatabaseConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id])

  @@map("proxy_connections")
}

enum QueryStatus {
  PENDING
  APPROVED
  REJECTED
  EXECUTED
  FAILED
}